package tcc.heronsanches.ufba.fim.utils;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.text.DecimalFormat;
import java.util.Random;
import java.util.logging.Level;
import java.util.logging.Logger;
import weka.classifiers.functions.MultilayerPerceptron;
import weka.core.Instance;
import weka.core.Instances;

/**These methods was based on examples of using of MultilayerPerceptron from http://www.lac.inpe.br/~rafael.santos/Docs/TreinamentoCTI2010/JavaDMVis.pdf
and using of cross-validation from here https://weka.wikispaces.com/Generating+cross-validation+folds+(Java+approach) and using a classifier to classifying a unlabeled instance from
here https://weka.wikispaces.com/Use+Weka+in+your+Java+code*/
public class MultilayerPerceptronWeka {
    
    private static final String PATH_CLASSIFIER = "classifier.mlp";
    
    
    /**@param pathToArffFile : path where is the arff file dataset
     @returns the statical results*/
    public static String stratifiedKCrossvalidation(String pathToArffFile){
        
        String resultTesting = "";
        String individualTesting = "";
        DecimalFormat df = new DecimalFormat("#.##");
        int datasetSize;
        
        try {
            
            FileReader reader = new FileReader (pathToArffFile);
            Instances instancies = new Instances (reader);
            instancies.setClassIndex (instancies.numAttributes() - 1);
            datasetSize = instancies.numInstances();
            
            //creates classifier based on Multilayer Perceptrons
            MultilayerPerceptron mlp = new MultilayerPerceptron ();
            mlp.setAutoBuild (true);
            mlp.setLearningRate (0.7);
            mlp.setMomentum (0.2);
            mlp.setTrainingTime (1000);
            mlp.setHiddenLayers ("5");
            
            int tse; //true side effect
            int tnse; //true no side effect
            int fse; //false side effect
            int fnse; //false no side effect
            int qttInstacies;
            double meanPrecision;
            double meanRecall;
            double meanAccuracy;
            int ttse = 0; //total true side effect
            int ttnse = 0; //total true no side effect
            int tfse = 0; //total false side effect
            int tfnse = 0; //total false no side effect
            int tQttInstacies = 0; //total 
            double tMeanPrecision = 0; //total mean
            double tMeanRecall = 0; //total mean
            double tMeanAccuracy = 0; //total mean
            double auxPrecision = 0;
            double auxRecall = 0;
            int ic; //instance class generated by the classifier
            int iClass; //instance class
            
            int seed;
            int folds = 10; //TODO enhancement: passes it how a parameter
            int runs = 200; //TODO enhancement: passes it how a parameter
            
            for(int i=0; i < runs; i++){ //repeats "runs" times the stratifyed-cross-validation
            
                seed = i + 1;
                Random rand = new Random(seed);
                Instances randData = new Instances(instancies);
                randData.randomize(rand);
                randData.stratify(folds);
                
                qttInstacies = 0;
                meanPrecision = 0;
                meanRecall = 0;
                meanAccuracy = 0;
                
                for(int n=0; n < folds; n++){ //stratifyed-cross-validation
                    
                    Instances train = randData.trainCV(folds, n);
                    Instances test = randData.testCV(folds, n);
                    
                    //training network
                    mlp.buildClassifier(train);
                    
                    qttInstacies += test.numInstances();
                    Instance instanceTest;
                    tse = 0; 
                    tnse = 0;
                    fse = 0; 
                    fnse = 0;

                    for(int j =0; j < test.numInstances(); j++){ //classifying
                        
                        instanceTest = test.instance(j); //recovery the instance
                        ic = (int)mlp.classifyInstance(instanceTest); //classifies the instance
                        iClass = (int)instanceTest.classValue();

                        if (ic == iClass){ //true classification

                            if(instanceTest.classAttribute().value(iClass).contentEquals("yes")) //siddeEffect
                                tse++;
                            else
                                tnse++;

                        }else{ //false classification

                            if(instanceTest.classAttribute().value(iClass).contentEquals("yes"))
                                fse++;
                            else
                                fnse++;

                        }

                    }
                    
                    ttse += tse;
                    ttnse += tnse;
                    tfse += fse;
                    tfnse += fnse;
                    
                    /*measurements
                        precision = tp/tp+fp
                        recall = tp/tp+fn
                        accuracy = tp+tn/tp+tn+fp+fn
                    */
                    
                    meanAccuracy +=  ((((double)tse+tnse) / (tse+tnse+fse+fnse)) / folds);
                    auxPrecision = (double)tse / (tse+fse);
                    auxRecall = (double)tse / (tse+fnse);
                            
                    if(!Double.isNaN(auxPrecision))
                        meanPrecision += (auxPrecision / folds);
                    
                    if(!Double.isNaN(auxRecall))
                        meanRecall += (auxRecall / folds);
                    
                }
                 
                tQttInstacies += qttInstacies;
                tMeanAccuracy += (meanAccuracy / runs);
                tMeanPrecision += (meanPrecision / runs);
                tMeanRecall += (meanRecall / runs);
                    
                individualTesting += "number of instancies: "+qttInstacies+"\n"
                            + "mean precision: "+df.format( meanPrecision * 100)+"%\n"
                            + "mean recall: "+df.format(meanRecall * 100)+"%\n"
                            + "mean accuracy: "+df.format( meanAccuracy * 100)+"%\n"
                            + "************************************************\n\n";
                
            }
            
            resultTesting += "*********************stratified-k-fold-crossvalidation*********************\n"
                    + "number of instancies: "+datasetSize
                    + "\nnumber of repetitions: "+runs
                    + "\nk-folds: "+folds+"\n\n"
                +"REDE\n"
                    + "Hidden Layers: "+mlp.getHiddenLayers()+"\n"
                    + "Revision: "+mlp.getRevision()+"\n"
                    + "Learning rate: "+mlp.getLearningRate()+"\n"
                    + "Momentum: "+mlp.getMomentum()+"\n"
                    + "Seed: "+mlp.getSeed()+"\n"
                    + "Training time: "+mlp.getTrainingTime()+"\n"
                    + "Validation set size: "+mlp.getValidationSetSize()+"\n"
                    + "Validation threshould: "+mlp.getValidationThreshold()+"\n\n"
                +"TOTAL RESULT\n"
                    + "number of instancies: "+tQttInstacies+"\n"
                    + "true side effect: "+ttse+"\n"
                    + "true no side effect: "+ttnse+"\n"
                    + "false side effect: "+tfse+"\n"
                    + "false no side effect: "+tfnse+"\n\n"
                    + "precision: "+df.format( ( ((double)ttse / (ttse+tfse))) * 100)+"%\n"
                    + "recall: "+df.format(( ((double)ttse / (ttse+tfnse))) * 100)+"%\n"
                    + "accuracy: "+df.format( (((double)ttse+ttnse) / (ttse+ttnse+tfse+tfnse)) * 100)+"%\n\n"
                +"MEAN RESULT\n"
                    + "mean precision: "+df.format(tMeanPrecision * 100)+"%\n"
                    + "mean recall: "+df.format(tMeanRecall * 100)+"%\n"
                    + "mean accuracy: "+df.format(tMeanAccuracy * 100)+"%\n\n"
                +"INDIVIDUAL RESULTS\n"+individualTesting;
                        
        } catch (IOException ex) {
            Logger.getLogger(MultilayerPerceptronWeka.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            Logger.getLogger(MultilayerPerceptronWeka.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return resultTesting;
        
    }
    
    
    /**@param pathToArffFile : path where is the arff file dataset
     @returns the statical results*/
    public static String holdoutRandomized(String pathToArffFile){
        
        String resultTesting = "";
        String resultInd = "";
        DecimalFormat df = new DecimalFormat("#.##");
        int datasetSize;
        
        try {
            
            FileReader reader = new FileReader (pathToArffFile);
            Instances instancies = new Instances (reader);
            instancies.setClassIndex (instancies.numAttributes() - 1);
            datasetSize = instancies.numInstances();
            
            //creates classifier based on Multilayer Perceptrons
            MultilayerPerceptron mlp = new MultilayerPerceptron ();
            mlp.setAutoBuild (true);
            mlp.setLearningRate (0.7);
            mlp.setMomentum (0.2);
            mlp.setTrainingTime (1000);
            mlp.setHiddenLayers ("5");
            
            /** total */
            int tse = 0; //true side effect
            int tnse = 0; //true no side effect
            int fse = 0; //false side effect
            int fnse = 0; //false no side effect
            int qttInstacies = 0;
            
            double meanPrecision = 0;
            double meanRecall = 0;
            double meanAccuracy = 0;
            
            /** individual **/
            int tseInd; //true side effect
            int tnseInd; //true no side effect
            int fseInd; //false side effect
            int fnseInd; //false no side effect

            int ic; //instance class generated by the classifier
            int iClass; //instance class
            
            int seed;
            int trainSize;
            int testSize;
            int runs = 5000; //TODO enhancement: passes it how a parameter
            double percentToTrain = 0.2174; //TODO enhancement: passes it how a parameter integer and make the necessary modification on calc
            double auxPrecision = 0;
            double auxRecall = 0;
            double auxAccuracy = 0;
            
            for(int i=0; i < runs; i++){ //repeats "runs" times the holdout-randomized
            
                //randomizes instancies
                seed = i + 1;
                Random rand = new Random(seed);
                Instances randData = new Instances(instancies);
                randData.randomize(rand);
                
                //split train and test
                trainSize = (int) Math.round(randData.numInstances() * percentToTrain);
                testSize = randData.numInstances() - trainSize;
                Instances train = new Instances(randData, 0, trainSize);
                Instances test = new Instances(randData, trainSize, testSize);
                
                tseInd = 0; 
                tnseInd = 0;
                fseInd = 0; 
                fnseInd = 0;

                //training network
                mlp.buildClassifier(train);

                qttInstacies += test.numInstances();
                Instance instanceTest;

                for(int j =0; j < test.numInstances(); j++){ //classifying

                    instanceTest = test.instance(j); //recovery the instance
                    ic = (int)mlp.classifyInstance(instanceTest); //classifies the instance
                    iClass = (int)instanceTest.classValue();

                    if (ic == iClass){ //true classification

                        if(instanceTest.classAttribute().value(iClass).contentEquals("yes")){ //siddeEffect
                            
                            tse++;
                            tseInd++;
                            
                        }else{
                            
                            tnse++;
                            tnseInd++;
                            
                        }
                        
                    }else{ //false classification

                        if(instanceTest.classAttribute().value(iClass).contentEquals("yes")){
                            
                            fse++;
                            fseInd++;
                            
                        }else{
                            
                            fnse++;
                            fnseInd++;
                            
                        }
                        
                    }

                }  
                    
                /*measurements
                    precision = tp/tp+fp
                    recall = tp/tp+fn
                    accuracy = tp+tn/tp+tn+fp+fn
                */
                
                auxAccuracy = ((double)tseInd+tnseInd) / (tseInd+tnseInd+fseInd+fnseInd);
                auxPrecision = (double)tseInd / (tseInd+fseInd);
                auxRecall = (double)tseInd / (tseInd+fnseInd);
                meanAccuracy += (auxAccuracy / runs);
                
                if(!Double.isNaN(auxPrecision))
                    meanPrecision += (auxPrecision /runs);
                
                if(!Double.isNaN(auxRecall))
                    meanRecall += (auxRecall /runs);
                    
                resultInd += 
                    "number of instancies: "+test.numInstances()+"\n"
                    + "true side effect: "+tseInd+"\n"
                    + "true no side effect: "+tnseInd+"\n"
                    + "false side effect: "+fseInd+"\n"
                    + "false no side effect: "+fnseInd+"\n\n"
                    + "precision: "+df.format(auxPrecision * 100)+"%\n"
                    + "recall: "+df.format(auxRecall  * 100)+"%\n"
                    + "accuracy: "+df.format(auxAccuracy  * 100)+"%\n"
                    + "***************************************************************************************\n\n";
                
            }
            
            resultTesting += "*********************repeated-randomized-holdout*********************\n"
                    + "number of instancies: "+datasetSize
                    + "\nnumber of repetitions: "+runs
                    + "\npercent to train: "+df.format(percentToTrain * 100)+"%"
                    + "\npercent to test: "+df.format((1 - percentToTrain) * 100)+"%\n\n"
                +"REDE\n"
                    + "Hidden Layers: "+mlp.getHiddenLayers()+"\n"
                    + "Revision: "+mlp.getRevision()+"\n"
                    + "Learning rate: "+mlp.getLearningRate()+"\n"
                    + "Momentum: "+mlp.getMomentum()+"\n"
                    + "Seed: "+mlp.getSeed()+"\n"
                    + "Training time: "+mlp.getTrainingTime()+"\n"
                    + "Validation set size: "+mlp.getValidationSetSize()+"\n"
                    + "Validation threshould: "+mlp.getValidationThreshold()+"\n\n"
                +"TOTAL RESULT\n"
                    + "number of instancies: "+qttInstacies+"\n"
                    + "true side effect: "+tse+"\n"
                    + "true no side effect: "+tnse+"\n"
                    + "false side effect: "+fse+"\n"
                    + "false no side effect: "+fnse+"\n\n"
                    + "precision: "+df.format( ((double)tse / (tse+fse)) * 100)+"%\n"
                    + "recall: "+df.format(((double)tse / (tse+fnse)) * 100)+"%\n"
                    + "accuracy: "+df.format( (((double)tse+tnse) / (tse+tnse+fse+fnse)) * 100)+"%\n\n"
                +"MEAN RESULT\n"
                    + "mean precision: "+df.format(meanPrecision * 100)+"%\n"
                    + "mean recall: "+df.format(meanRecall * 100)+"%\n"
                    + "mean accuracy: "+df.format(meanAccuracy * 100)+"%\n\n"
                +"INDIVIDUAL RESULTS\n"+resultInd;
                        
        } catch (IOException ex) {
            Logger.getLogger(MultilayerPerceptronWeka.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            Logger.getLogger(MultilayerPerceptronWeka.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return resultTesting;
        
    }
    
    
    /**@param pathToArffFile : path where is the arff file training*/
    public static boolean trainingNetwork(String pathToArffFile){
        
        ObjectOutputStream oos = null;
        
        try {
            
            FileReader reader = new FileReader(pathToArffFile);
            Instances instancies = new Instances(reader);
            instancies.setClassIndex(instancies.numAttributes() - 1);
            
            //creates classifier based on Multilayer Perceptrons
            MultilayerPerceptron mlp = new MultilayerPerceptron ();
            mlp.setAutoBuild (true);
            mlp.setLearningRate (0.7);
            mlp.setMomentum (0.2);
            mlp.setTrainingTime (1000);
            mlp.setHiddenLayers ("5");

            //training network
            mlp.buildClassifier(instancies);

            //saves classifier to use in other moment
            oos = new ObjectOutputStream (new FileOutputStream(MultilayerPerceptronWeka.PATH_CLASSIFIER));
            oos.writeObject(mlp);
            oos.close();
            
            return true;
                        
        } catch (IOException ex) {
            Logger.getLogger(MultilayerPerceptronWeka.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            Logger.getLogger(MultilayerPerceptronWeka.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return false;
                
    }
    
    
    /**@param pathToArffFile : path where is the arff file testing*/
    public static String testingNetwork(String pathToArffFile) throws Exception{
        
       ObjectInputStream ois = null;
       String resultTesting = "";
       
        try {
            
            //get the salved classifier
            ois = new ObjectInputStream (new FileInputStream(MultilayerPerceptronWeka.PATH_CLASSIFIER));
            MultilayerPerceptron mlp = (MultilayerPerceptron) ois.readObject();
            ois.close ();
            
            //get the instancies on arff
            FileReader reader = new FileReader (pathToArffFile);
            Instances instancies = new Instances(reader);
            instancies.setClassIndex(instancies.numAttributes() - 1);
            
            int tse = 0; //true side effect
            int tnse = 0; //true no side effect
            int fse = 0; //false side effect
            int fnse = 0; //false no side effect
            
            int qttInstacies = instancies.numInstances();
            Instance instance;
            int ic; //class by classifier
            int iClass; //instance class
            
            //classifying
            for (int i =0; i < instancies.numInstances(); i++){
                
                //Recovery the instance
                instance = instancies.instance(i);
                
                iClass = (int)instance.classValue();
                
                //Classifies the instance
                ic = (int)mlp.classifyInstance(instance);
                
                if (ic == iClass){ //true classification
                    
                    if(instance.classAttribute().value(iClass).contentEquals("yes")) //siddeEffect
                        tse++;
                    else
                        tnse++;
                    
                }else{ //false classification
                    
                    if(instance.classAttribute().value(iClass).contentEquals("yes"))
                        fse++;
                    else
                        fnse++;
                    
                }
                
            }   
            
            DecimalFormat df = new DecimalFormat("#.####");
            
            /*measurements
                precision = tp/tp+fp
                recall = tp/tp+fn
                accuracy = tp+tn/tp+tn+fp+fn
            */
                
            resultTesting += "number of instancies: "+qttInstacies+"\n"
                    + "true side effect: "+tse+"\n"
                    + "true no side effect: "+tnse+"\n"
                    + "false side effect: "+fse+"\n"
                    + "false no side effect: "+fnse+"\n\n"
                    + "precision: "+df.format( ((double)tse / (tse+fse)) * 100)+"%\n"
                    + "recall: "+df.format(((double)tse / (tse+fnse)) * 100)+"%\n"
                    + "accuracy: "+df.format( (((double)tse+tnse) / (tse+tnse+fse+fnse)) * 100)+"%\n";
            
        } catch (IOException | ClassNotFoundException | NullPointerException ex) {
            Logger.getLogger(MultilayerPerceptronWeka.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return resultTesting;
        
    }
    
    
    /**@param pathToArffFile : path where is the arff file to classify*/
    public static boolean isSideEffect(String pathToArffFile){ 
                
        try {
        
            ObjectInputStream ois = null;
            ois = new ObjectInputStream (new FileInputStream(MultilayerPerceptronWeka.PATH_CLASSIFIER));
            MultilayerPerceptron mlp = (MultilayerPerceptron) ois.readObject();
            ois.close ();

            Instances uInstances = new Instances(new FileReader (pathToArffFile)); //unlabeled instance
            uInstances.setClassIndex(uInstances.numAttributes() -1);
            Instance lInstance = new Instance(uInstances.instance(0)); //copy of unlabeled instance
            int ic = (int)mlp.classifyInstance(uInstances.instance(0)); //classifies the instance
            lInstance.setClassValue(ic);

            if(lInstance.classAttribute().value(ic).contentEquals("yes"))
                return true;
            
        } catch (IOException | ClassNotFoundException ex) {
            Logger.getLogger(MultilayerPerceptronWeka.class.getName()).log(Level.SEVERE, null, ex);
        } catch (Exception ex) {
            Logger.getLogger(MultilayerPerceptronWeka.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        return false;
        
    }

    
}